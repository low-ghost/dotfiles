set noshowmode
let g:bufferline_echo=0
let g:jsx_ext_required = 0

"typescript support for neocomplete
let g:Tsuquyomi_use_dev_node_module=2
let g:Tsuquyomi_tsserver_path="/home/mbagwell/.nvm/versions/node/v5.5.0/bin/tsserver"
if !exists('g:neocomplete#force_omni_input_patterns')
  let g:neocomplete#force_omni_input_patterns = {}
endif
let g:neocomplete#force_omni_input_patterns.typescript = '[^. *\t]\.\w*\|\h\w*::'
autocmd Filetype typescript setlocal omnifunc=tsuquyomi#complete
autocmd BufNewFile,BufRead *.ts set filetype=typescript
autocmd BufNewFile,BufRead *.tsx set filetype=typescript

nnoremap <leader>ss :s///g<Left><Left><Left><C-f>i
nnoremap <leader>sw :s/\(<C-r><C-w>\)/\1/g<Left><Left>
nnoremap <leader>sa :%s/\(<C-r><C-w>\)/\1/g<Left><Left>

nnoremap <Leader>; A;<Esc>
"nnoremap <c-x> :wall!<CR>:mksession! Session.vim<CR>
let g:EasyMotion_smartcase = 1

nnoremap <Leader>eneo :NeoSnippetEdit<CR>
nnoremap <Leader>rneo :NeoSnippetMakeCache<CR>

inoremap <C-e> <Esc>A
inoremap <C-b> <Esc>i
inoremap <C-f> <Esc>la

let g:snips_author = 'Michael Bagwell <Michael_Bagwell@excelmicro.com>'

"function! TestFileNameToVar()
"let b:origFile = substitute(expand("%:t:r"), "Test", "", "")
"" doesn't work
"let b:origFileVar = substitute(b:origFile, "(\a)", "\L\1", "g")
"let b:stringToMod = "nnoremap <leader>emod :e ../../models/" . b:origFile . ".php<cr>"
"exec b:stringToMod
"return b:origFile
"endfunction

"function! Laravel()
"let g:LARAROOT = fnamemodify(b:git_dir, ":h")
"let stringToCon = "nnoremap <leader>ecn :e " . g:LARAROOT . "/app/config/CSAConsole.php<cr>"
"exec stringToCon
"let stringToRoute = "nnoremap <leader>ert :e " . g:LARAROOT . "/app/routes.php<cr>"
"exec stringToRoute
"command! -nargs=+ Laragrep execute 'silent grep! -r --exclude-dir={node_modules,plugins,vendor,git,logs,meta} <args> '.LARAROOT | copen 33
"endfunction

"nnoremap <Leader>th bi$this-><Esc>
"nnoremap <Leader>bug yiwovar_dump(<Esc>pa);<Esc>

"nnoremap <Space>re _ceconst/frm€kbomct'= requix€kbre(lxf;i)j_

"select last pasted block
nnoremap gp `[v`]

" BufOnly.vim  -  Delete all the buffers except the current/named buffer.
"
" Copyright November 2003 by Christian J. Robinson <infynity@onewest.net>
"
" Distributed under the terms of the Vim license.  See ":help license".
"
" Usage:
"
" :Bonly / :BOnly / :Bufonly / :BufOnly [buffer] 
"
" Without any arguments the current buffer is kept.  With an argument the
" buffer name/number supplied is kept.

command! -nargs=? -complete=buffer -bang Bonly
      \ :call BufOnly('<args>', '<bang>')
command! -nargs=? -complete=buffer -bang BOnly
      \ :call BufOnly('<args>', '<bang>')
command! -nargs=? -complete=buffer -bang Bufonly
      \ :call BufOnly('<args>', '<bang>')
command! -nargs=? -complete=buffer -bang BufOnly
      \ :call BufOnly('<args>', '<bang>')

function! BufOnly(buffer, bang)
  if a:buffer == ''
    " No buffer provided, use the current buffer.
    let buffer = bufnr('%')
  elseif (a:buffer + 0) > 0
    " A buffer number was provided.
    let buffer = bufnr(a:buffer + 0)
  else
    " A buffer name was provided.
    let buffer = bufnr(a:buffer)
  endif

  if buffer == -1
    echohl ErrorMsg
    echomsg "No matching buffer for" a:buffer
    echohl None
    return
  endif

  let last_buffer = bufnr('$')

  let delete_count = 0
  let n = 1
  while n <= last_buffer
    if n != buffer && buflisted(n)
      if a:bang == '' && getbufvar(n, '&modified')
        echohl ErrorMsg
        echomsg 'No write since last change for buffer'
              \ n '(add ! to override)'
        echohl None
      else
        silent exe 'bdel' . a:bang . ' ' . n
        if ! buflisted(n)
          let delete_count = delete_count+1
        endif
      endif
    endif
    let n = n+1
  endwhile

  if delete_count == 1
    echomsg delete_count "buffer deleted"
  elseif delete_count > 1
    echomsg delete_count "buffers deleted"
  endif

endfunction

"vimux functions
function! VimuxSlime()
  call VimuxSendText(@v)
  call VimuxSendKeys("Enter")
endfunction

"TODO: check address existence
"Possible TODO: localize to script
function! VimuxPlexGetAddress(specified_address)

  if a:specified_address
    "directly pass address as the second argument
    return
      \ type(a:specified_address) == 1
      \ ? a:specified_address
      \ : string(a:specified_address)
  elseif exists("v:count") && v:count != 0
    "join a two digit count with a dot so that 10 refers to 1.0 or window 1,
    "pane 0. could also give 3 numbers to indicate session...
    return join(split(string(v:count), '\zs'), '.')
  elseif exists("g:VimuxPlexLastAddress")
    "use last address as the default
    return g:VimuxPlexLastAddress
  else
    "if no last address, prompt for input
    return input('Enter address number: ')
  endif

endfunction

"Runs a command to an address based on pane from count, arg, last address,
"or prompt. Args: command, address (0 if passing to other optional sources),
"and auto_return (0 if prevent the default of sending an enter key)
"Persists last command and address in variables and in a dict
function! VimuxPlexRunCommand(command, ...)

  let address = VimuxPlexGetAddress(exists("a:1") ? a:1 : 0)

  if empty(address)
    echo "No address specified"
    return 0
  endif

  let l:auto_return = 1
  if exists("a:2")
    let l:auto_return = a:2
  endif

  let reset_sequence =
    \ exists("g:VimuxPlexResetSequence")
    \ ? g:VimuxPlexResetSequence
    \ : "q C-u"
  "save to global last command, last address and a dict of key=last address
  "value=last command
  let g:VimuxPlexLastCommand = a:command
  let g:VimuxPlexLastAddress = address
  if !exists("g:VimuxPlexLastCommandDict")
    let g:VimuxPlexLastCommandDict = {}
  endif
  let g:VimuxPlexLastCommandDict[address] = a:command

  call VimuxPlexSendKeys(reset_sequence, address)
  call VimuxPlexSendText(a:command, address)

  if l:auto_return == 1
    call VimuxPlexSendKeys("Enter", address)
  endif

endfunction

"run last command from dict based on pane from count, arg, last address,
"or prompt. If no last command and buffer exists send, 'Up' and 'Enter'
function! VimuxPlexRunLastCommand(...)
  let address = VimuxPlexGetAddress(exists("a:1") ? a:1 : 0)
  if empty(address)
    echo "No address specified"
    return 0
  endif
  if exists("g:VimuxPlexLastCommandDict")
    let command = get(g:VimuxPlexLastCommandDict, address, 'Up')
    call VimuxPlexRunCommand(command, address)
  endif
endfunction

"ask for a command to run and execute it in pane from count, arg, last address, or prompt
function! VimuxPlexPromptCommand(...)
  let default = a:0 == 1 ? a:1 : ""
  let command = input(
    \ exists("g:VimuxPlextPromptString")
    \ ? g:VimuxPromptString
    \ : "Command? "
    \ , default)
  if empty(command)
    echo "No command specified"
  else
    call VimuxPlexRunCommand(command)
  endif
endfunction

"kill a specific address
function! VimuxPlexCloseAddress()
  let address = VimuxPlexGetAddress(exists("a:1") ? a:1 : 0)
  if empty(address)
    echo "No address specified"
    return 0
  endif
  call system("tmux kill-pane -t ".address)
endfunction

"turns pane into a window and a window into a pane
"TODO
"function! VimuxPlexToggleAddress()
"  if _VimuxRunnerType() == "window"
"    call system("tmux join-pane -d -s ".g:VimuxRunnerIndex." -p "._VimuxOption("g:VimuxHeight", 20))
"    let g:VimuxRunnerType = "pane"
"  elseif _VimuxRunnerType() == "pane"
"    let g:VimuxRunnerIndex = substitute(system("tmux break-pane -d -t ".g:VimuxRunnerIndex." -P -F '#{window_index}'"), "\n", "", "")
"    let g:VimuxRunnerType = "window"
"  endif
"endfunction

"travel to an address and zoom in
function! VimuxPlexZoomAddress(...)
  let address = VimuxPlexGetAddress(exists("a:1") ? a:1 : 0)
  if empty(address)
    echo "No address specified"
    return 0
  endif
  call VimuxPlexGoToAddress(address)
  call system("tmux resize-pane -Z -t ".address)
endfunction

"function to return to last vim address, good for functions that need to be in
"the pane to execute but return to original vim. See VimuxPlexScrollUpInspect
"and ...Down...
function! s:VimuxPlexReturnToLastVimAddress()
  let split_address = split(g:VimuxPlexLastVimAddress, '\.')
  call system("tmux select-window -t ".split_address[0]."; tmux select-pane -t ".split_address[1])
endfunction

"travel to address, insert copy mode, page up, then return to vim
function! VimuxPlexScrollUpInspect(...)
  let address = VimuxPlexGetAddress(exists("a:1") ? a:1 : 0)
  call VimuxPlexInspectAddress(address)
  call s:VimuxPlexReturnToLastVimAddress()
  call VimuxPlexSendKeys("C-u", address)
endfunction

"travel to address, insert copy mode, page down, then return to vim
function! VimuxPlexScrollDownInspect(...)
  let address = VimuxPlexGetAddress(exists("a:1") ? a:1 : 0)
  call VimuxPlexInspectAddress(address)
  call s:VimuxPlexReturnToLastVimAddress()
  call VimuxPlexSendKeys("C-d", address)
endfunction

"send an interrupt sequence (control-c) to address
function! VimuxPlexInterruptAddress(...)
  let address = VimuxPlexGetAddress(exists("a:1") ? a:1 : 0)
  if empty(address)
    echo "No address specified"
    return 0
  endif
  let g:VimuxPlexLastAddress = address
  call VimuxPlexSendKeys("^C", address)
endfunction

"clear an address's tmux history and clear the terminal
function! VimuxPlexClearAddressHistory(...)
  let address = VimuxPlexGetAddress(exists("a:1") ? a:1 : 0)
  if empty(address)
    echo "No address specified"
    return 0
  endif
  let g:VimuxPlexLastAddress = address
  call system("tmux clear-history -t ".address)
  call VimuxPlexSendText("clear", address)
  call VimuxPlexSendKeys("Enter", address)
endfunction

"send escaped text by calling VimuxPlexSendKeys. Needs text and pane explicitly
function! VimuxPlexSendText(text, address)
  call VimuxPlexSendKeys('"'.escape(a:text, '"$').'"', a:address)
endfunction

"send specific keys to a tmux pane. Needs keys and address explicitly
function! VimuxPlexSendKeys(keys, address)
  let address = type(a:address) == 1 ? a:address : string(a:address)
  call system("tmux send-keys -t ".address." ".a:keys)
endfunction

"travel to an address and persist it as the last-used
function! VimuxPlexGoToAddress(...)
  let address = VimuxPlexGetAddress(exists("a:1") ? a:1 : 0)
  if empty(address)
    echo "No address specified"
    return 0
  endif

  "set vim and tmux VimuxPlexLastVimAddress variables
  let g:VimuxPlexLastVimAddress = system("tmux display-message -p '#I.#P'")
  call system("tmux set-environment VimuxPlexLastVimAddress ".g:VimuxPlexLastVimAddress)
  let g:VimuxPlexLastAddress = address

  let split_address = split(address, '\.')

  if len(split_address) == 2
    call system("tmux select-window -t ".split_address[0]."; tmux select-pane -t ".split_address[1])
  else
    call system("tmux select-pane -t ".split_address[0])
  endif
endfunction

"enter window and pane in copy mode
"Possible TODO: handle session based three part pane address
function! VimuxPlexInspectAddress(...)
  let address = VimuxPlexGetAddress(exists("a:1") ? a:1 : 0)
  if empty(address)
    echo "No address specified"
    return 0
  endif
  call VimuxPlexGoToAddress(address)
  call system("tmux copy-mode")
endfunction

if !exists("g:VimuxPlexLoaded")
  let g:VimuxPlexLoaded = 1
  "mappings which accept a count to specify the window and pane
  "one digit is pane only e.g. 1<mapping> is an action for pane 1
  "two digits is window, pane e.g. 12<mapping> is an action for window 1, pane 2
  nnoremap <unique> <Plug>VimuxPlexPromptCommand :<C-U>call VimuxPlexPromptCommand()<CR>
  nnoremap <unique> <Plug>VimuxPlexRunLastCommand :<C-U>call VimuxPlexRunLastCommand()<CR>
  nnoremap <unique> <Plug>VimuxPlexInspectAddress :<C-U>call VimuxPlexInspectAddress()<CR>
  nnoremap <unique> <Plug>VimuxPlexClearAddressHistory :<C-U>call VimuxPlexClearAddressHistory()<CR>
  nnoremap <unique> <Plug>VimuxPlexInterruptAddress :<C-U>call VimuxPlexInterruptAddress()<CR>
  nnoremap <unique> <Plug>VimuxPlexZoomAddress :<C-U>call VimuxPlexZoomAddress()<CR>
  nnoremap <unique> <Plug>VimuxPlexGoToAddress :<C-U>call VimuxPlexGoToAddress()<CR>
  nnoremap <unique> <Plug>VimuxPlexScrollUpInspect :<C-U>call VimuxPlexScrollUpInspect()<CR>
  nnoremap <unique> <Plug>VimuxPlexScrollDownInspect :<C-U>call VimuxPlexScrollDownInspect()<CR>
  nnoremap <unique> <Plug>VimuxPlexCloseAddress :<C-U>call VimuxPlexCloseAddress()<CR>
endif

"example mappings
nmap ,vp <Plug>VimuxPlexPromptCommand
nmap ,vl <Plug>VimuxPlexRunLastCommand
nmap ,vi <Plug>VimuxPlexInspectAddress
nmap ,vc <Plug>VimuxPlexClearAddressHistory
nmap ,vx <Plug>VimuxPlexInterruptAddress
nmap ,vz <Plug>VimuxPlexZoomAddress
nmap ,vg <Plug>VimuxPlexGoToAddress
nmap ,vk <Plug>VimuxPlexScrollUpInspect
nmap ,vj <Plug>VimuxPlexScrollDownInspect
nmap ,vq <Plug>VimuxPlexCloseAddress

"insert functions
function! AppendLine()
  let c = v:count
  let i = 0
  while i <= c
    call append(line("."), "")
    let i += 1
  endwhile
endfunction

function! PrependLine()
  let l:scrolloffsave = &scrolloff
  " Avoid jerky scrolling with ^E at top of window
  set scrolloff=0
  let c = v:count
  let i = 0
  while i <= c
    call append(line(".") - 1, "")
    let i += 1
  endwhile
  if winline() != winheight(0)
    silent normal! <C-e>
  end
  let &scrolloff = l:scrolloffsave
endfunction

"fixes a few bugs
inoremap <Esc> <Esc><Esc>
"easy-motion searches
map ,, <Plug>(easymotion-prefix)
map ,,s <Plug>(easymotion-s)
map ,n <Plug>(easymotion-sn)
map ,2 <Plug>(easymotion-s2)
"easy-motion prefix is <leader><leader>

"spacemacs keys

"spacemacs windows
nnoremap <silent> <Space>wd :hide<cr>;
nnoremap <silent> <Space>wj <C-W>j;
nnoremap <silent> <Space>wk <C-W>k;
nnoremap <silent> <Space>wh <C-W>h;
nnoremap <silent> <Space>wl <C-W>l;
nnoremap <silent> <Space>ws <C-W>s;
nnoremap <silent> <Space>wv <C-W>v;
nnoremap <silent> <Space>w= <C-W>=;
nnoremap <silent> <Space>wO :only<CR>
"spacemacs commands
nnoremap <silent> <Space>x q:
"spacemacs buffers
"both delete accept count to specify buffer
nnoremap <silent> <Space>bd :bp\|bd #<CR>
nnoremap <silent> <Space>bD :bp\|bd! #<CR>
"BOnly will not kill buffers w/ unsaved content
nnoremap <silent> <Space>bo :BOnly<CR>
nnoremap <silent> <Space>bb :CtrlPBuffer<CR>
"bp/h and bn/l accept count
nnoremap <silent> <Space>bp :bprev<CR>
nnoremap <silent> <Space>bh :bprev<CR>
nnoremap <silent> <Space>bn :bnext<CR>
nnoremap <silent> <Space>bl :bnext<CR>
"copy entire buffer
nnoremap <silent> <Space>by gg"+yG<CR>
nnoremap <silent> <Space>bY gg"+yG<CR>
"replace entire buffer with register
"TODO accept register
nnoremap <silent> <Space>bP gg"_dGp<CR>
nnoremap <silent> <Space>br :e! %<CR>
"spacemacs file
nnoremap <silent> <Space><CR> :w<CR>
nnoremap <silent> <Space>fs :w<CR>
nnoremap <silent> <Space>fS :wa<CR>
nnoremap <silent> <Space>fw :silent w !sudo tee % > /dev/null<CR>
nnoremap <silent> <Space>fe :NERDTreeTabsToggle<CR>
nnoremap <silent> <Space>ff :CtrlP<CR>
nnoremap <silent> <Space>fr :CtrlPMRUFiles<CR>
nnoremap <silent> <Space>fve :e $MYVIMRC<CR>
nnoremap <silent> <Space>fvl :e ~/.vimrc.local<CR>
nnoremap <silent> <Space>fvr :source $MYVIMRC<CR>
nnoremap <silent> <Space>fte :e ~/.tmux.conf<CR>
nnoremap <silent> <Space>ftr :call system("tmux source-file ~/.tmux.conf")<CR>
"spacemacs quit
nnoremap <silent> <Space>qq :qa<CR>
nnoremap <silent> <Space>qQ :qa!<CR>
nnoremap <silent> <Space>qs :wqa!<CR>
"spacemacs toggle
nnoremap <silent> <Space>tn :set nu!<CR>
nnoremap <silent> <Space>tN :set relativenumber!<CR>
nnoremap <silent> <Space>ts :set invhlsearch<CR>
nnoremap <silent> <Space>thl :set cursorline!<CR>
"spacemacs insert
nnoremap <silent> <space>ij :<C-U>call AppendLine()<CR>
"nnoremap <space>io :<C-U>call AppendLine()<CR>i
nnoremap <silent> <Space>ik :<C-U>call PrependLine()<CR>
"nnoremap <space>iO :<C-U>call PrependLine()<CR>i
"spacemacs applications
nnoremap <silent> <Space>au :UndotreeToggle<CR>
"spacemacs repl
nnoremap <silent> <Space>rc :VimuxPromptCommand<CR>
nnoremap <silent> <Space>rl :VimuxRunLastCommand<CR>
"list tmux panes
nnoremap <silent> <Space>rpl :echo system('tmux lsp -a -F "#S:#{=10:window_name}-#I:#P #{pane_current_command} #{?pane_active,(active),}"')<CR>
"todo nnoremap <silent> <Space>rpc :let g:vimux<CR>
"send return key to runner to exit inspect mode
nnoremap <silent> <Space>ri :VimuxInspectRunner<CR>
nnoremap <silent> <Space>ri<CR> :VimuxInspectRunner<CR>
nnoremap <silent> <Space>rig :VimuxInspectRunner<CR>
nnoremap <silent> <Space>rir :call VimuxSendKeys("Enter")<CR>
nnoremap <silent> <Space>rik :call VimuxScrollUpInspect()<CR>
nnoremap <silent> <Space>rij :call VimuxScrollDownInspect()<CR>
nnoremap <silent> <Space>rz :VimuxZoomRunner<CR>
nnoremap <silent> <Space>rq :VimuxCloseRunner<CR>
vnoremap <silent> <Space>rsr "vy :call VimuxSlime()<CR>
nnoremap <silent> <Space>rsr vip "vy :call VimuxSlime()<CR>
vnoremap <silent> <Space>rsR "vy :call VimuxSlime()<CR>:VimuxInspectRunner<CR>
nnoremap <silent> <Space>rsR vip "vy :call VimuxSlime()<CR>:VimuxInspectRunner<CR>
nnoremap <silent> <Space>rsb gg"vyG :call VimuxSlime()<CR>
nnoremap <silent> <Space>rsB gg"vyG :call VimuxSlime()<CR>:VimuxInspectRunner<CR>
"spacemacs comment
"<space>c<space> is annoying but leaving it for habit's sake
nmap <silent> <space>cl <plug>NERDCommenterToggle
nmap <silent> <space>c<space> <plug>NERDCommenterToggle
"just listing defaults
"<space>cc <plug>NERDComComment>
"<space>cn <plug>NERDComNestedComment
"<space>cm <plug>NERDComMinimalComment
"<space>ci <plug>NERDComInvertComment
"<space>cs <plug>NERDComSexyComment
"<space>cy <plug>NERDComYankComment
"<space>c$ <plug>NERDComEOLComment
"<space>cA <plug>NERDComAppendComment
"<space>ca <plug>NERDComAltDelim
"<space>cb <plug>NERDComAlignedComment
"<space>cu <plug>NERDComUncommentLine

"TODO multiline backtick
"additional motions

if !exists('g:additional_motions')

  "underscore
  call textobj#user#plugin('underscore', {
        \      '-': {
        \        '*sfile*': expand('<sfile>:p'),
        \        'select-a': 'a_',  '*select-a-function*': 's:underscore_select_a',
        \        'select-i': 'i_',  '*select-i-function*': 's:underscore_select_i'
        \      }
        \    })

  function! s:underscore_select_a()
    normal F_
    let end_pos = getpos('.')
    normal f_
    let start_pos = getpos('.')
    return ['v', start_pos, end_pos]
  endfunction

  function! s:underscore_select_i()
    normal T_
    let end_pos = getpos('.')
    normal t_
    let start_pos = getpos('.')
    return ['v', start_pos, end_pos]
  endfunction

  "dot
  call textobj#user#plugin('dot', {
        \      '-': {
        \        '*sfile*': expand('<sfile>:p'),
        \        'select-a': 'a.',  '*select-a-function*': 's:dot_select_a',
        \        'select-i': 'i.',  '*select-i-function*': 's:dot_select_i'
        \      }
        \    })

  function! s:dot_select_a()
    normal F.
    let end_pos = getpos('.')
    normal f.
    let start_pos = getpos('.')
    return ['v', start_pos, end_pos]
  endfunction

  function! s:dot_select_i()
    normal T.
    let end_pos = getpos('.')
    normal t.
    let start_pos = getpos('.')
    return ['v', start_pos, end_pos]
  endfunction

  "slash
  call textobj#user#plugin('slash', {
        \      '-': {
        \        '*sfile*': expand('<sfile>:p'),
        \        'select-a': 'a/',  '*select-a-function*': 's:slash_select_a',
        \        'select-i': 'i/',  '*select-i-function*': 's:slash_select_i'
        \      }
        \    })

  function! s:slash_select_a()
    normal F/
    let end_pos = getpos('.')
    normal f/
    let start_pos = getpos('.')
    return ['v', start_pos, end_pos]
  endfunction

  function! s:slash_select_i()
    normal T/
    let end_pos = getpos('.')
    normal t/
    let start_pos = getpos('.')
    return ['v', start_pos, end_pos]
  endfunction

  "pasted/yanked
  call textobj#user#plugin('pasted', {
        \      '-': {
        \        '*sfile*': expand('<sfile>:p'),
        \        'select-a': 'agp', '*select-a-function*': 's:pasted_select_a',
        \        'select-i': 'igp', '*select-i-function*': 's:pasted_select_i',
        \   },
        \ })

  function! s:pasted_select_i()
    normal `]
    let end_pos = getpos('.')
    normal `[
    let start_pos = getpos('.')
    return ['v', end_pos, start_pos]
  endfunction

  function! s:pasted_select_a()
    normal ']$
    let end_pos = getpos('.')
    normal '[0
    let start_pos = getpos('.')
    return ['v', end_pos, start_pos]
  endfunction

  "selected
  call textobj#user#plugin('selected', {
        \      '-': {
        \        '*sfile*': expand('<sfile>:p'),
        \        'select-a': 'agp', '*select-a-function*': 's:selected_select_a',
        \        'select-i': 'igp', '*select-i-function*': 's:selected_select_i',
        \   },
        \ })

  function! s:selected_select_i()
    normal `>
    let end_pos = getpos('.')
    normal `<
    let start_pos = getpos('.')
    return ['v', end_pos, start_pos]
  endfunction

  function! s:selected_select_a()
    normal '>$
    let end_pos = getpos('.')
    normal '<0
    let start_pos = getpos('.')
    return ['v', end_pos, start_pos]
  endfunction

  "line
  call textobj#user#plugin('line', {
        \      '-': {
        \        '*sfile*': expand('<sfile>:p'),
        \         'select-a': 'al', '*select-a-function*': 's:line_select_a',
        \         'select-i': 'il', '*select-i-function*': 's:line_select_i',
        \  },
        \ })

  function! s:line_select_a()
    normal! 0
    let head_pos = getpos('.')
    normal! $
    let tail_pos = getpos('.')
    return ['v', head_pos, tail_pos]
  endfunction

  function! s:line_select_i()
    normal! ^
    let head_pos = getpos('.')
    normal! g_
    let tail_pos = getpos('.')
    let non_blank_char_exists_p = getline('.')[head_pos[2] - 1] !~# '\s'
    return
          \ non_blank_char_exists_p
          \ ? ['v', head_pos, tail_pos]
          \ : 0
  endfunction

  let g:additional_motions = 1
endif
