#!/bin/zsh

# $1: function - completion function
# $2: function - function itself, expecting one arg
# $3: any - initial parameter
fzf-ize() {
  completion_func=$1
  func=$2
  initial_param=$3
  local _eval_fzf() {
    if [ -z "$1" ]; then
      result=`$completion_func | fzf -1`
      if [ -z "$result" ]; then
        echo 'no items were chosen'
        return
      fi
    else
      result=$1
    fi
    { # try
      $func $result 2>/dev/null
    } || { # catch
      result=`$completion_func | fzf -1 -q $result`
      if [ -z "$result" ]; then
        echo 'no items were chosen'
        return
      fi
      $func $result
    }
  }
  _eval_fzf $initial_param
}

# ejson {
# TODO: if has .json
encjson() { ejson encrypt $1.json }
decjson() { ejson decrypt $1.json | tee t.json && mv t.json $1.json }
# }

whatsonport() { sudo netstat -tulnap | grep :$1 }

clip() { "$1" | xclip -sel clip }

his() {
  if [ -z "$1" ]; then
      history
  else
      history | grep "$@"
  fi
}
_his_completion () {
  grep --help
}
_his () {
  compadd -S '' `_his_completion`
}

# docker {

alias dc='docker-compose'
alias dcs='docker-compose stop'
alias ds='docker stop'
alias dps='docker ps'

dstopall() { docker stop $(docker ps -a -q) }
alias drmall='docker rm $(docker ps -a -q)'
dbuild() {
  dir=${PWD##*/}
  docker build -t ${1-$dir} .
}
dockerlink() { docker run -it --link $1:postgres --rm postgres sh -c 'exec psql -h "$POSTGRES_PORT_5432_TCP_ADDR" -p "$POSTGRES_PORT_5432_TCP_PORT" -U exm-app-development exm-development' }

# }
# node {

alias nvmc='nvm current'
alias nvma='nvm alias'
alias nvmi='nvm install'
alias nvml='nvm ls'
alias nlo='nvm exec latest node ~/repo/js-repl/standard/lo'
alias nlo3='nvm exec latest node ~/repo/js-repl/lo3/lo3'
alias nvlo='NODE_NO_READLINE=1 rlwrap -P "const [lo, fp] = [require(\"lodash\"), require(\"lodash/fp\")];" -r --always-readline node'
alias ncw='nvm exec latest node ~/repo/js-repl/standard/cw'
alias ncwp='APP_ENV=production nvm exec latest node ~/repo/js-repl/standard/cw'
alias ncws='APP_ENV=staging R=true nvm exec latest node ~/repo/js-repl/standard/cw'
alias npml='npm link'

nvmu(){
  nvm use $1 && sed -i 's/\(nvm use \).*\( > \/dev\/null\)/\1'$1'\2/' ~/.zshrc                                                                                              feature-dockerize  +2
}

# }
# git {

# stash, but keep files
alias -g gstai='git stash --keep-index'
# same, but more fun
alias -g gstain='git stash --keep-index'
# ignore file in git
alias -g gic='git update-index --assume-unchanged'
# ignore dir in git
gicd() {
  git update-index --assume-unchanged `git ls-files --directory $1 -z` > /dev/null 2>&1
}
# restore watching file in git
alias -g ungic='git update-index --no-assume-unchanged'
#unignore dir
ungicd() {
  git update-index --no-assume-unchanged `git ls-files --directory $1 -z` > /dev/null 2>&1
}
alias -g gcan='git commit -a -n -m'
gpan() {
  echo "Enter a message"
  read message
  `git commit -a -n -m $message; ggpush`
}
alias -g gde='git branch --edit-description'
gds() {
  git config branch.$(git rev-parse --abbrev-ref HEAD).description
}
gda() {
  for branch in $(git for-each-ref --format='%(refname)' refs/heads/ | sed 's|refs/heads/||'); do
    desc=$(git config branch.$branch.description)
    if [ $branch == $(git rev-parse --abbrev-ref HEAD) ]; then
      branch="* \033[0;32m$branch\033[0m"
    else
      branch="  $branch"
    fi
    echo -e "$branch \033[0;36m$desc\033[0m"
  done
}

# git unadd: remove file from
gun() { git reset HEAD $@ ;}
_gitunadd_completion() {
  git diff --cached --name-only --diff-filter=A
}
_gitunadd () {
  compadd -S '' `_gitunadd_completion`
}

# generate git ignore from gitignore.io
gi() { curl -sL https://www.gitignore.io/api/`echo $@ | sed s/" "/,/g` ;}
_gitignoreio_completion() {
  curl -sL https://www.gitignore.io/api/list | tr "," "\n"
}
_gitignoreio () {
  compset -P '*,'
  compadd -S '' `_gitignoreio_completion`
}

# clone from the excel micro repo
gclex() {
  if [ -z "$1" ]; then
    repo=`_gclex_completion | fzf`
    if [ -z "$repo" ]; then
      echo 'no repo chosen'
      return
    fi
  else
    repo=$1
  fi
  git clone git@bitbucket.org:excelmicro/$repo.git ~/repo/$repo
}
_gclex_completion() {
  cat ~/repo/.temp_list | jq '.values | .[].full_name' | sed 's:"excelmicro/\(.*\)":\1:g'
}
_gclex () {
  compset -P '*,'
  compadd -S '' `_gclex_completion`
}

# }
# apt {

alias apt='sudo apt-get'
alias apti='sudo apt-get install'
alias aptu='sudo apt-get update'

# }

# simple calculations
calc() { echo $1 | bc -l }

alias pgdevstart='docker run -d -p 5432:5432 postgres'

pyserve() {
  if [ -z "$1" ]; then
    timeout 1h python -m SimpleHTTPServer; notify-send 'python server shutdown'
  else
    timeout "$@" python -m SimpleHTTPServer; notify-send 'python server shutdown'
  fi
}
alias rdevstart='docker run -p 6379:6379 -d redis'

pgexm() {
    if [ $# -eq 0 ]; then
        command psql -h $PG_HOST_EXM -U $PG_USER_EXM -d $PG_DB_EXM
    elif [ $# -eq 1 ]; then
        command psql -h $PG_HOST_EXM -U $PG_USER_EXM -d $PG_DB_EXM -c $1 -t
    else
        command psql -h $PG_HOST_EXM -U $PG_USER_EXM -d $PG_DB_EXM -c "SELECT array_to_json(array_agg(row_to_json(fooo))) FROM ($1) AS fooo;" -t | jq $2
    fi
}

pgprod() {
    if [ $# -eq 0 ]; then
        command psql -h $PG_HOST_EXM -U $PG_USER_EXM -d $PG_DB_PROD
    elif [ $# -eq 1 ]; then
        command psql -h $PG_HOST_EXM -U $PG_USER_EXM -d $PG_DB_PROD -c $1 -t
    else
        command psql -h $PG_HOST_EXM -U $PG_USER_EXM -d $PG_DB_PROD -c "SELECT array_to_json(array_agg(row_to_json(fooo))) FROM ($1) AS fooo;" -t | jq $2
    fi
}

pgloc() {
    if [ $# -eq 0 ]; then
        command psql -h localhost -U $PG_USER_LOC -d exm-production
    elif [ $# -eq 1 ]; then
        command psql -h localhost -U $PG_USER_LOC -d exm-production -c $1 -t
    else
        command psql -h localhost -U $PG_USER_LOC -d exm-production -c "SELECT array_to_json(array_agg(row_to_json(fooo))) FROM ($1) AS fooo;" -t | jq $2
    fi
}

pgjacob() {
    if [ $# -eq 0 ]; then
        command psql -h 192.168.0.218 -U $PG_USER_LOC -d $PG_DB_EXM
    elif [ $# -eq 1 ]; then
        command psql -h 192.168.0.218 -U $PG_USER_LOC -d $PG_DB_EXM -c $1 -t
    else
        command psql -h 192.168.0.218 -U $PG_USER_LOC -d $PG_DB_EXM -c "SELECT array_to_json(array_agg(row_to_json(fooo))) FROM ($1) AS fooo;" -t | jq $2
    fi
}

pgsta() {
    if [ $# -eq 0 ]; then
        command psql -h $PG_HOST_EXM -U $PG_USER_LOC -d exm-staging
    elif [ $# -eq 1 ]; then
        command psql -h $PG_HOST_EXM -U $PG_USER_LOC -d exm-staging -c $1 -t
    else
        command psql -h $PG_HOST_EXM -U $PG_USER_LOC -d exm-staging -c "SELECT array_to_json(array_agg(row_to_json(fooo))) FROM ($1) AS fooo;" -t | jq $2
    fi
}
groot() {
  git rev-parse --show-toplevel
}
# change dir to git root
alias cdg='cd `groot`'

_cdr_pre_fzf() { cd ~/repo/$1 }
_cdr_completion() {
  ls ~/repo
}
_cdr() {
  compset -P '*,'
  compadd -S '' `_cdr_completion`
}
cdr() {
  fzf-ize "_cdr_completion" "_cdr_pre_fzf" $1
}
# start a test environment
alias testenv='env $(ejson decrypt test.json | python ./env.py) docker-compose -f pg-redis.yml up'

# master git
alias gcom='git checkout master'

# npm view
alias npmv='npm view'

function npmvv() {
  npm view $1 versions
}

# npm install
alias npmi='npm i'
alias npmis='npm i -S'
alias npmid='npm i -D'
alias npmig='npm i -g'

# google and firefox
goog() {
  firefox google.com/#q=$1
  sleep .5
  wmctrl -a 'google'
}

fire() {
  firefox -vimperator "+c 'js liberator.sleep(1000) && liberator.open(\"$@\")'"
}

# raise spotify window
alias spo="wmctrl -ia `wmctrl -lx | grep spotify.Spotify | awk '{ print $0 }'`"

# notify current track info
spoc() {
  current=`. ~/sp current`
  notify-send $current
}

# get the jira issue from the current branch name
alias gitissue="git rev-parse --abbrev-ref HEAD | sed 's/.*-\(.*\)-\(.*\)/\1-\2/'"
gcmi() {
  git commit -m "`gitissue`: $1"
}
gcmin() {
  git commit -n -m "`gitissue`: $1"
}
# better xev
alias xev='xev | sed -ne '/^KeyPress/,/^$/p''

alias gbcur="git rev-parse --abbrev-ref HEAD"
gb_to_issue() {
  echo $1 | sed 's/^[[:alnum:]]*-\([[:alnum:]]*\)-\([[:alnum:]]*\).*/\1-\2/'
}
# jira issue
jiraissue() {
  curl -s --netrc-file ~/.jira-netrc -X GET -H "Content-Type:application/json" \
    https://excelmicro.atlassian.net/rest/api/2/issue/$1 | jq .fields.summary
}
gname() {
  git remote show origin -n | grep "Fetch URL:" | sed -E 's:^.*/(.*).git$:\1:g'
}
# jira issue from git
gjira() {
  if [ $# -eq 0 ]; then
    issue=`gb_to_issue `gbcur``
    project_name=`gname`
  elif [ $# -eq 1 ]; then
    issue=`gb_to_issue $1`
    project_name=`gname`
  else
    issue=`gb_to_issue $1`
    project_name=$2
  fi
  cached_file_dir=$HOME/.jira-descriptions/$project_name
  cached_file_loc=$cached_file_dir/$issue
  if [ -f $cached_file_loc ]; then
    cat $cached_file_loc
  else
    summary=`jiraissue $issue`
    mkdir -p $cached_file_dir
    touch $cached_file_loc
    echo $summary > $cached_file_loc
    echo $summary
  fi
}

gbjira() {
  remote=false
  color=true
  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      -r|--remote) remote=true;;
      -n|--nocolor) color=false;;
    esac
    shift
  done
  if [ "$remote" = true ]; then
    branches=(`git branch -r | cut -c 3-`)
  else
    branches=(`git for-each-ref --format='%(refname)' refs/heads/ | sed 's|refs/heads/||'`)
  fi
  for unformatted_branch in $branches; do
    branch=`echo $unformatted_branch | sed 's/^[[:alnum:]]*\///'`
    desc=`gjira $branch`
    if [ $branch == `git rev-parse --abbrev-ref HEAD` ]; then
      if [ $color == true ]; then
        branch="* \033[0;32m$branch\033[0m"
      else
        branch="* $branch"
      fi
    else
      branch="  $branch"
    fi
    if [ $color == true ]; then
      echo -e "$branch: \033[0;36m$desc\033[0m"
    else
      echo -e "$branch: $desc"
    fi
  done
}
_gcof_pre_fzf() {
  gco `echo $1 | sed 's/^..\(.*\):\(.*\)/\1/'`
}
_gcof_completion() {
  gbjira -r -n
}
_gcof () {
  compset -P '*,'
  compadd -S '' `_gcof_completion`
}
gcof() {
  fzf-ize "_gcof_completion" "_gcof_pre_fzf" $1
}
#alias gbc="gbjira | grep `gbcur`"
bb() {
  while [[ "$#" -gt 1 ]]; do
    case "$1" in
      -b|--branch) branch="$2";;
      -p|--project) project_name="$2";;
    esac
    shift
  done
  project_name=${project_name:=`gname`}
  branch=${branch:=`gbcur`}
  firefox https://bitbucket.com/excelmicro/$project_name/src/?at=$branch
}

# TODO: execute a file
#alias pgexec='echo "SELECT array_to_json(array_agg(row_to_json(fooo))) FROM (`cat modules/sql/audit/retrieval.sql | sed 's/;//g'`) AS fooo;" | sed 's/to_timestamp(\$.)/now()/g' | sed 's/\$/:v/g' | psql -h $PG_HOST_EXM -U $PG_USER_LOC -d exm-staging -t -v v1=62530 -v v2=314 | jq .'

# typescript to json helper
tsc-json() {
  ./node_modules/typescript-json-schema/bin/typescript-json-schema \
    models/$1/types.d.ts $2 --keywords errorMessage,id,title --required > schema/$1/$3.json
}

# thesaurus lookup
thesaur() {
  curl http://words.bighugelabs.com/api/2/$THES_KEY/$1/json | jq .
}
alias other-words='thesaur'

pr() {
  branch=`gbcur`
  bitbucket pull_request --owner excelmicro --title "$branch: $2" $branch $1
}
